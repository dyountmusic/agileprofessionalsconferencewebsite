<!DOCTYPE html>
<html lang="en">

<head>
    <title>Rapid Protyping in Agile</title>
    <meta name="Article" content="APC 2018">
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../global.css">
</head>

<body>

    <nav class="topnav" id="myTopnav">
        <a href="../index.html">Home</a>
        <a href="../articlelist.html" class="active">Article List</a>
    </nav>
    <header>

    </header>

    <main>

        <div class="box">
            <h1>Rapid Prototyping in Agile</h1>
            <article>
                <intro>
                    <strong>Prototyping.</strong> From my experience working with developers, this word may illicit a strong positive reaction or an intense negative reaction. If we dig further into why this word has the tendency to incur strong emotional reaction, however, you might be surprised at how a large percentage of developers misunderstand and have come to dislike the concept prototyping through the process that it is implemented through.
                </intro>
                <content>
                    <p>
                        Traditionally, prototyping was considered a one off phase in something like the waterfall methodology. With this methodology, developers and designers would spend an extremely large amount of time at the beginning of a project brainstorming, mocking up, designing, redesigning and more or less fleshing out a design in its entirety before taking hands to keyboard for code. Once the prototype worked and was ‘complete’ (as far as the developers could see), the design was finalized and set in stone. It could not be changed without breaking the core tenants of the waterfall methodology. This leads to issues… to put it lightly.
                    </p>
                    <p>
                        When you are prototyping at a high level without a deep understanding of the technical and practical limitations of the project, you make assumptions. These assumptions are often underestimated assumptions such as: “We have plenty of time to get this UI up and running” (thus, underestimating the time commitment it will take to, in fact, get this UI up and running) or an overestimated assumption such as: “This icon will only take a few days to implement” (when, in actuality, it takes weeks to design and redesign as the designers re-draw and refine the icon).
                    </p>
                    <p>
                        Both practices of under and over estimation hurt a project in one way or another. The strict and unyielding nature of waterfall, however, makes it nigh impossible to revise or change requirements midway through the process. Once the ‘prototype’ has been approved, the developers and designers are on a contractual mission to bring the product to life with pixel perfect attention to detail to the specifications of what was agreed upon in the requirements/designing phase.
                    </p>
                    <h1>Agile is different.</h1>
                    <p>
                        In agile, we constantly prototype small, quick, and just barely functioning pieces of a product to flesh out our technical, UX, and overall design understanding of how it fits into the product upon delivery to the customer. What’s more, we incorporate the customer into this process. We invite targeted user groups in for prototype testing and constantly gather feedback to make small adjustments to the direction as needed.
                    </p>
                    <p>
                        We may over or underestimate value or time needed on certain features, but the iterative based nature of how agile timelines work enables the team and the scrum master to consistently reevaluate expectations and if needed communicate them to the customer(s).
                    </p>
                    <p>
                        When developers and designers use agile in conjunction with prototyping the experience is not a disjointed and isolated affair, rather a consistent drum beat of progress that is used in a feedback loop to set expectations, communicate requirements to developers and enable customer interaction throughout the project to ensure the team is building exactly what the customer is expecting.
                    </p>
                    <p>
                        To give a real world example of this process: Say a developer is working on an iOS app that delivers real time notifications on the whereabouts of a local food truck or even a group of food trucks around a popular US city. The customer has expressed interest in a feature that allows a user to upload and post reviews of food truck menus to this application. Instead of jumping straight into the programming phase or going off on a long and drawn out designing process, an agile team might consider a few strategies but ultimately settle on quickling sketching out visual designs on a whiteboard, prototyping the UI in Sketch and animating it in Keynote, and finally prototyping some of the iOS SDK interactions with Xcode’s Playground. None of this process should take more than a few days, but by the end of it, the developers, designers, and customers will have an idea of what works, what doesn’t and even what is still ambiguous.
                    </p>
                    <p>
                        Agile can improve the success of projects, especially projects involving software. By incorporating a rapid prototyping process into your sprints, each feature can be designed and developed more fully and will ultimately contribute to a happier end user. Developers will also appreciate experimenting with small isolated code environments that enable them to work over an SDK integration without fear or anxiety of breaking or committing to an architecture style. It’s a win-win for everyone.
                    </p>

                </content>
                
            </article>
        </div>

    </main>

    <footer>
        <p>Copyright © APC 2018<br> info@apc2018.com
        </p>
        <p>developed by Team 5</p>
        <br>
    </footer>

</body>

</html>